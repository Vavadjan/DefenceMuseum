/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
!function() {

;// CONCATENATED MODULE: ./repo/js/libs/logger.js
var onlyErrorsToConsole = false;
var consoleLogs = true;
var consoleDebug = true;
var alertOnError = false;
var alertOnLog = false;
function log() {
  if (!onlyErrorsToConsole) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (consoleLogs) (_console = console).log.apply(_console, args);
    if (alertOnLog) alert(args.join(" :: "));
  }
}
function debug() {
  var _console2;
  if (!onlyErrorsToConsole && consoleDebug) (_console2 = console).debug.apply(_console2, arguments);
}
function error() {
  var _console3;
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (!onlyErrorsToConsole && consoleDebug) (_console3 = console).error.apply(_console3, args);
  if (alertOnError) alert(args.join(" :: "));
}
;// CONCATENATED MODULE: ./repo/js/libs/utils.js
function isEmpty(value) {
  return value === null || value === undefined || value === "";
}
function getTargetElem(target) {
  if (target instanceof HTMLElement) {
    return target;
  } else {
    var elem = document.querySelector(target);
    if (!elem) new Error("Cannot find the target by selector: ".concat(target));
    return elem;
  }
}
function formatPrice(value) {
  var normalizedValue = typeof value === "string" ? value.trim().replace(" ", "") : String(value);
  var result = [];
  var tmp = normalizedValue.split("");
  // return normalizedValue.split(/\B(?=(\d{3})+$)/).join(" ");
  while (tmp.length > 0) {
    result.unshift(tmp.splice(-3).join(""));
  }
  return result.join(" ");
}
function forEachProp(obj, callback) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    callback(keys[i], obj[keys[i]]);
  }
}
;
var createElem = function createElem(name, attrs, container) {
  var el = document.createElement(name);
  if (attrs) forEachProp(attrs, function (key, value) {
    return el.setAttribute(key, value);
  });
  if (container) container.appendChild(el);
  return el;
};
var normalizeString = function normalizeString(value) {
  return String(value).toLowerCase().trim();
};
;// CONCATENATED MODULE: ./repo/components/drawers/index.js
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }


log("Started loading drawers api to global scope");
var _bodyScrollLock = bodyScrollLock,
  lock = _bodyScrollLock.lock,
  unlock = _bodyScrollLock.unlock;
var isAsync = function isAsync(target) {
  return target.constructor.name === "AsyncFunction";
};
var initialLayerZIndex = 200;
var defaultOptions = {
  overlapping: true,
  static: false,
  closeOnEsc: true,
  closeOnOutsideClick: true,
  closeConfirm: function closeConfirm(drawer) {
    return true;
  }
};
function addActiveClassToBtn(elem) {
  if (elem instanceof HTMLElement) {
    elem.classList.add("active");
  }
}
function removeActiveClassFromBtn(elem) {
  if (elem instanceof HTMLElement) {
    elem.classList.remove("active");
  }
}
var _state = /*#__PURE__*/new WeakMap();
var Drawer = /*#__PURE__*/function () {
  function Drawer(elem, alias) {
    var userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, Drawer);
    _classPrivateFieldInitSpec(this, _state, {
      writable: true,
      value: {
        zIndex: null,
        focus: false,
        open: false,
        locked: false,
        upperOverlapping: false
      }
    });
    _defineProperty(this, "subscribers", {
      close: [],
      open: []
    });
    _defineProperty(this, "components", {
      openBtnElems: [],
      closeBtnElems: [],
      toggleBtnElems: []
    });
    var options = {
      __proto__: defaultOptions,
      on: {}
    };
    this.elem = elem;
    this.alias = alias;
    this.params = Object.assign(options, userOptions);
    debug("Drawer has been initialized: ", alias);
  }
  _createClass(Drawer, [{
    key: "zIndex",
    get: function get() {
      return _classPrivateFieldGet(this, _state).zIndex;
    },
    set: function set(val) {
      _classPrivateFieldGet(this, _state).zIndex = val;
      this.elem.style.setProperty("z-index", val);
    }
  }, {
    key: "focus",
    get: function get() {
      return _classPrivateFieldGet(this, _state).focus;
    },
    set: function set(value) {
      _classPrivateFieldGet(this, _state).focus = value;
      if (value) {
        this.elem.classList.add("focus");
      } else {
        this.elem.classList.remove("focus");
      }
    }
  }, {
    key: "upperOverlapping",
    get: function get() {
      return _classPrivateFieldGet(this, _state).upperOverlapping;
    },
    set: function set(value) {
      _classPrivateFieldGet(this, _state).upperOverlapping = value;
      if (value) {
        this.elem.classList.add("upper-overlapping");
      } else {
        this.elem.classList.remove("upper-overlapping");
      }
    }
  }, {
    key: "locked",
    get: function get() {
      return _classPrivateFieldGet(this, _state).locked;
    },
    set: function set(value) {
      _classPrivateFieldGet(this, _state).locked = value;
      if (value) lock(this.elem);else unlock(this.elem);
    }
  }, {
    key: "on",
    value: function on(type, callback) {
      if (type in this.subscribers) {
        this.subscribers[type].push(callback);
      }
    }
  }, {
    key: "overlapping",
    get: function get() {
      return this.params.overlapping;
    },
    set: function set(value) {
      this.params.overlapping = value;
      if (value) this.elem.classList.add("drawer_overlapping");else this.elem.classList.remove("drawer_overlapping");
      Drawer.resetUpperOverlapping();
    }
  }, {
    key: "addOpenBtn",
    value: function addOpenBtn(target) {
      var _this = this;
      var openBtnElem = getTargetElem(target);
      this.components.openBtnElems.push(openBtnElem);
      openBtnElem.addEventListener("click", function (event) {
        event.__drawerOpen = true;
        _this.open(openBtnElem);
      });
    }
  }, {
    key: "addCloseBtn",
    value: function addCloseBtn(target) {
      var _this2 = this;
      var closeBtnElem = getTargetElem(target);
      this.components.closeBtnElems.push(closeBtnElem);
      closeBtnElem.addEventListener("click", function (event) {
        event.__drawerClose = true;
        _this2.close(closeBtnElem);
      });
    }
  }, {
    key: "addToggleBtn",
    value: function addToggleBtn(target) {
      var _this3 = this;
      var toggleBtnElem = getTargetElem(target);
      this.components.toggleBtnElems.push(toggleBtnElem);
      toggleBtnElem.addEventListener("click", function (event) {
        if (_classPrivateFieldGet(_this3, _state).open) {
          event.__drawerClose = true;
          _this3.close(toggleBtnElem);
        } else {
          event.__drawerOpen = true;
          _this3.open(toggleBtnElem);
        }
      });
    }
  }, {
    key: "open",
    value: function open(initiator) {
      var _this4 = this;
      console.log("Open Drawer Native", this, initiator);
      if (_classPrivateFieldGet(this, _state).open) return;
      this.components.openBtnElems.forEach(addActiveClassToBtn);
      this.components.closeBtnElems.forEach(addActiveClassToBtn);
      this.components.toggleBtnElems.forEach(addActiveClassToBtn);
      if (this.params.overlapping || this.params.static) {
        // Add event listeners
        this.locked = true;
        if (Drawer.upperOverlapping) {
          Drawer.upperOverlapping.upperOverlapping = false;
        }
        this.upperOverlapping = true;
        Drawer.upperOverlapping = this;
      }
      // Get upper overlapping
      this.zIndex = Drawer.upperZIndex + 1;
      this.elem.classList.add("open");
      this.initiator = initiator;
      _classPrivateFieldGet(this, _state).open = true;
      Drawer.openDrawersList.push(this);
      this.subscribers.open.forEach(function (callback) {
        return callback(_this4);
      });
    }
  }, {
    key: "close",
    value: function close() {
      var _this5 = this;
      console.log("Close Drawer Native", this);
      if (!_classPrivateFieldGet(this, _state).open) return;
      this.components.openBtnElems.forEach(removeActiveClassFromBtn);
      this.components.closeBtnElems.forEach(removeActiveClassFromBtn);
      this.components.toggleBtnElems.forEach(removeActiveClassFromBtn);
      this.elem.classList.remove("open");
      this.locked = false;
      _classPrivateFieldGet(this, _state).open = false;
      var drawerIdx = Drawer.openDrawersList.findIndex(function (drawer) {
        return drawer.alias === _this5.alias;
      });
      Drawer.openDrawersList.splice(drawerIdx, 1);
      Drawer.resetUpperOverlapping();
      this.subscribers.close.forEach(function (callback) {
        return callback(_this5);
      });
    }
  }, {
    key: "handleEsc",
    value: function () {
      var _handleEsc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.params.closeOnEsc && !this.params.static)) {
                _context.next = 5;
                break;
              }
              _context.next = 3;
              return this.params.closeConfirm(this);
            case 3:
              if (!_context.sent) {
                _context.next = 5;
                break;
              }
              this.close();
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function handleEsc(_x) {
        return _handleEsc.apply(this, arguments);
      }
      return handleEsc;
    }()
  }, {
    key: "handleOutsideClick",
    value: function () {
      var _handleOutsideClick = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(event) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(event.target === this.initiator)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return");
            case 2:
              if (!(this.params.closeOnOutsideClick && !this.params.static)) {
                _context2.next = 7;
                break;
              }
              _context2.next = 5;
              return this.params.closeConfirm(this);
            case 5:
              if (!_context2.sent) {
                _context2.next = 7;
                break;
              }
              this.close();
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function handleOutsideClick(_x2) {
        return _handleOutsideClick.apply(this, arguments);
      }
      return handleOutsideClick;
    }()
  }, {
    key: "handleUnderlayClick",
    value: function () {
      var _handleUnderlayClick = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.params.closeOnOutsideClick && !this.params.static)) {
                _context3.next = 5;
                break;
              }
              _context3.next = 3;
              return this.params.closeConfirm(this);
            case 3:
              if (!_context3.sent) {
                _context3.next = 5;
                break;
              }
              this.close();
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function handleUnderlayClick(_x3) {
        return _handleUnderlayClick.apply(this, arguments);
      }
      return handleUnderlayClick;
    }()
  }], [{
    key: "upperOpenDrawer",
    get: function get() {
      return Drawer.openDrawersList[Drawer.openDrawersList.length - 1];
    }
  }, {
    key: "upperOverlapping",
    get: function get() {
      return Drawer.state.upperOverlapping;
    },
    set: function set(drawer) {
      return Drawer.state.upperOverlapping = drawer;
    }
  }, {
    key: "resetUpperOverlapping",
    value: function resetUpperOverlapping() {
      if (Drawer.upperOverlapping) {
        Drawer.upperOverlapping.upperOverlapping = false;
      }
      var upperOverlapping = Drawer.openDrawersList.find(function (drawer) {
        return drawer.overlapping;
      });
      if (upperOverlapping) {
        upperOverlapping.upperOverlapping = true;
        Drawer.upperOverlapping = upperOverlapping;
      }
    }
  }, {
    key: "upperZIndex",
    get: function get() {
      if (Drawer.openDrawersList.length) {
        return Drawer.upperOpenDrawer.zIndex;
      } else {
        return initialLayerZIndex;
      }
    }
  }]);
  return Drawer;
}();
_defineProperty(Drawer, "openDrawersList", []);
_defineProperty(Drawer, "state", {
  upperOverlapping: null
});
if (!window.drawers) {
  window.drawers = function () {
    var kitchen = {};
    var drawersMap = {};
    kitchen.init = function (options) {
      debug("Start drawers initialization");
      var drawerElems = document.querySelectorAll("[data-drawer]");
      var controlElems = document.querySelectorAll("[data-drawer-open], [data-drawer-close], [data-drawer-toggle]");
      drawerElems.forEach(function (elem) {
        var drawerAlias = elem.getAttribute("data-drawer");
        drawersMap[drawerAlias] = new Drawer(elem, drawerAlias, options);
      });
      controlElems.forEach(function (elem) {
        if (elem.hasAttribute("data-drawer-open")) {
          var drawerAlias = elem.getAttribute("data-drawer-open");
          if (!drawersMap[drawerAlias]) return;
          drawersMap[drawerAlias].addOpenBtn(elem);
        } else if (elem.hasAttribute("data-drawer-close")) {
          var _drawerAlias = elem.getAttribute("data-drawer-close");
          if (!drawersMap[_drawerAlias]) return;
          drawersMap[_drawerAlias].addCloseBtn(elem);
        } else {
          var _drawerAlias2 = elem.getAttribute("data-drawer-toggle");
          if (!drawersMap[_drawerAlias2]) return;
          drawersMap[_drawerAlias2].addToggleBtn(elem);
        }
      });
      document.addEventListener("click", function (event) {
        if (event.__drawerOpen || event.__drawerClose) return;
        var target = event.target;
        var drawerPanelElem = target.closest(".drawer__panel, [data-drawer-panel]");
        if (drawerPanelElem) {// Inside click
        } else {
          var drawerElem = target.closest(".drawer");
          if (drawerElem) {
            var _drawersMap$alias;
            // Underlay click
            var alias = drawerElem.getAttribute("data-drawer");
            (_drawersMap$alias = drawersMap[alias]) === null || _drawersMap$alias === void 0 ? void 0 : _drawersMap$alias.handleUnderlayClick(event);
          } else {
            // Outside click
            Drawer.openDrawersList.forEach(function (drawer) {
              return drawer.handleOutsideClick(event);
            });
          }
        }
      });
      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape") {
          if (!Drawer.openDrawersList.length) return;
          Drawer.upperOpenDrawer.handleEsc(event);
        }
      });
    };
    kitchen.assign = function (target, alias, options) {
      if (alias in drawersMap) throw new Error("There is drawer already created with given alias: \"".concat(alias, "\""));
      var drawerElem = target instanceof HTMLElement ? target : document.querySelector(target);
      if (drawerElem) throw new Error("There is no element has been found by given selector: \"".concat(target, "\""));
      return drawersMap[alias] = new Drawer(drawerElem, alias, options);
    };
    kitchen.open = function (alias, initiator) {
      console.log("Open Drawer Kitchen", alias, initiator);
      if (!(alias in drawersMap)) throw new Error("There is no drawer created with given alias: \"".concat(alias, "\""));
      drawersMap[alias].open(initiator);
    };
    kitchen.close = function (alias) {
      console.log("Close Drawer Kitchen", alias);
      if (!(alias in drawersMap)) throw new Error("There is no drawer created with given alias: \"".concat(alias, "\""));
      drawersMap[alias].close();
    };
    kitchen.get = function (alias) {
      return drawersMap[alias];
    };
    kitchen.on = function (alias, type, callback) {
      var _kitchen$get;
      return (_kitchen$get = kitchen.get(alias)) === null || _kitchen$get === void 0 ? void 0 : _kitchen$get.on(type, callback);
    };
    return kitchen;
  }();
}
function bodyLock(targetElem) {
  lock(targetElem);
  var bodyElem = document.querySelector("body");
  bodyElem.classList.add("lock");
  var scrollableElems = targetElem.querySelectorAll("[data-scrollable]");
  scrollableElems.forEach(function (elem) {
    return lock(elem);
  });
}
function bodyUnlock(targetElem) {
  var removeUnderlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
  var bodyElem = document.querySelector("body");
  setTimeout(function () {
    if (removeUnderlay) {
      bodyElem.classList.remove("lock");
    }
    unlock(targetElem);
    var scrollableElems = targetElem.querySelectorAll("[data-scrollable]");
    scrollableElems.forEach(function (elem) {
      return unlock(elem);
    });
  }, delay);
}
;// CONCATENATED MODULE: ./repo/js/libs/functions.js
/* Проверка поддержки webp, добавление класса webp или no-webp для HTML */
function isWebp() {
  // Проверка поддержки webp 
  function testWebP(callback) {
    var webP = new Image();
    webP.onload = webP.onerror = function () {
      callback(webP.height == 2);
    };
    webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
  }
  // Добавление класса _webp или _no-webp для HTML
  testWebP(function (support) {
    var className = support === true ? 'webp' : 'no-webp';
    document.documentElement.classList.add(className);
  });
}
/* Проверка мобильного браузера */
var isMobile = {
  Android: function Android() {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function BlackBerry() {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function iOS() {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Opera: function Opera() {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function Windows() {
    return navigator.userAgent.match(/IEMobile/i);
  },
  any: function any() {
    return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
  }
};
/* Добавление класса touch для HTML если браузер мобильный */
function addTouchClass() {
  // Добавление класса _touch для HTML если браузер мобильный
  if (isMobile.any()) document.documentElement.classList.add('touch');
}
// Добавление loaded для HTML после полной загрузки страницы
function addLoadedClass() {
  window.addEventListener("load", function () {
    setTimeout(function () {
      document.documentElement.classList.add('loaded');
    }, 0);
  });
}
// Получение хеша в адресе сайта
function getHash() {
  if (location.hash) {
    return location.hash.replace('#', '');
  }
}
// Указание хеша в адресе сайта
function setHash(hash) {
  hash = hash ? "#".concat(hash) : window.location.href.split('#')[0];
  history.pushState('', '', hash);
}
// Учет плавающей панели на мобильных устройствах при 100vh
function fullVHfix() {
  var fullScreens = document.querySelectorAll('[data-fullscreen]');
  if (fullScreens.length && isMobile.any()) {
    var fixHeight = function fixHeight() {
      var vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
    };
    window.addEventListener('resize', fixHeight);
    fixHeight();
  }
}
// Вспомогательные модули плавного расскрытия и закрытия объекта ======================================================================================================================================================================
var _slideUp = function _slideUp(target) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var showmore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (!target.classList.contains('_slide')) {
    target.classList.add('_slide');
    target.style.transitionProperty = 'height, margin, padding';
    target.style.transitionDuration = duration + 'ms';
    target.style.height = "".concat(target.offsetHeight, "px");
    target.offsetHeight;
    target.style.overflow = 'hidden';
    target.style.height = showmore ? "".concat(showmore, "px") : "0px";
    target.style.paddingTop = 0;
    target.style.paddingBottom = 0;
    target.style.marginTop = 0;
    target.style.marginBottom = 0;
    window.setTimeout(function () {
      target.hidden = !showmore ? true : false;
      !showmore ? target.style.removeProperty('height') : null;
      target.style.removeProperty('padding-top');
      target.style.removeProperty('padding-bottom');
      target.style.removeProperty('margin-top');
      target.style.removeProperty('margin-bottom');
      !showmore ? target.style.removeProperty('overflow') : null;
      target.style.removeProperty('transition-duration');
      target.style.removeProperty('transition-property');
      target.classList.remove('_slide');
      // Создаем событие 
      document.dispatchEvent(new CustomEvent("slideUpDone", {
        detail: {
          target: target
        }
      }));
    }, duration);
  }
};
var _slideDown = function _slideDown(target) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var showmore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (!target.classList.contains('_slide')) {
    target.classList.add('_slide');
    target.hidden = target.hidden ? false : null;
    showmore ? target.style.removeProperty('height') : null;
    var height = target.offsetHeight;
    target.style.overflow = 'hidden';
    target.style.height = showmore ? "".concat(showmore, "px") : "0px";
    target.style.paddingTop = 0;
    target.style.paddingBottom = 0;
    target.style.marginTop = 0;
    target.style.marginBottom = 0;
    target.offsetHeight;
    target.style.transitionProperty = "height, margin, padding";
    target.style.transitionDuration = duration + 'ms';
    target.style.height = height + 'px';
    target.style.removeProperty('padding-top');
    target.style.removeProperty('padding-bottom');
    target.style.removeProperty('margin-top');
    target.style.removeProperty('margin-bottom');
    window.setTimeout(function () {
      target.style.removeProperty('height');
      target.style.removeProperty('overflow');
      target.style.removeProperty('transition-duration');
      target.style.removeProperty('transition-property');
      target.classList.remove('_slide');
      // Создаем событие 
      document.dispatchEvent(new CustomEvent("slideDownDone", {
        detail: {
          target: target
        }
      }));
    }, duration);
  }
};
var _slideToggle = function _slideToggle(target) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  if (target.hidden) {
    return _slideDown(target, duration);
  } else {
    return _slideUp(target, duration);
  }
};
// Вспомогательные модули блокировки прокрутки и скочка ====================================================================================================================================================================================================================================================================================
var bodyLockStatus = true;
var bodyLockToggle = function bodyLockToggle() {
  var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
  if (document.documentElement.classList.contains('lock')) {
    functions_bodyUnlock(delay);
  } else {
    functions_bodyLock(delay);
  }
};
var functions_bodyUnlock = function bodyUnlock() {
  var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
  var body = document.querySelector("body");
  if (bodyLockStatus) {
    var lock_padding = document.querySelectorAll("[data-lp]");
    setTimeout(function () {
      for (var index = 0; index < lock_padding.length; index++) {
        var el = lock_padding[index];
        el.style.paddingRight = '0px';
      }
      body.style.paddingRight = '0px';
      document.documentElement.classList.remove("lock");
    }, delay);
    bodyLockStatus = false;
    setTimeout(function () {
      bodyLockStatus = true;
    }, delay);
  }
};
var functions_bodyLock = function bodyLock() {
  var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
  var body = document.querySelector("body");
  if (bodyLockStatus) {
    var lock_padding = document.querySelectorAll("[data-lp]");
    for (var index = 0; index < lock_padding.length; index++) {
      var el = lock_padding[index];
      el.style.paddingRight = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';
    }
    body.style.paddingRight = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';
    document.documentElement.classList.add("lock");
    bodyLockStatus = false;
    setTimeout(function () {
      bodyLockStatus = true;
    }, delay);
  }
};
// Модуль работы со спойлерами =======================================================================================================================================================================================================================
/*
Документация по работе в шаблоне: https://template.fls.guru/template-docs/modul-spojlery.html
Сниппет (HTML): spollers
*/
function spollers() {
  var spollersArray = document.querySelectorAll('[data-spollers]');
  if (spollersArray.length > 0) {
    // Инициализация
    var initSpollers = function initSpollers(spollersArray) {
      var matchMedia = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      spollersArray.forEach(function (spollersBlock) {
        spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;
        if (matchMedia.matches || !matchMedia) {
          spollersBlock.classList.add('_spoller-init');
          initSpollerBody(spollersBlock);
          spollersBlock.addEventListener("click", setSpollerAction);
        } else {
          spollersBlock.classList.remove('_spoller-init');
          initSpollerBody(spollersBlock, false);
          spollersBlock.removeEventListener("click", setSpollerAction);
        }
      });
    }; // Работа с контентом
    var initSpollerBody = function initSpollerBody(spollersBlock) {
      var hideSpollerBody = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var spollerTitles = spollersBlock.querySelectorAll('[data-spoller]');
      if (spollerTitles.length) {
        spollerTitles = Array.from(spollerTitles).filter(function (item) {
          return item.closest('[data-spollers]') === spollersBlock;
        });
        spollerTitles.forEach(function (spollerTitle) {
          if (hideSpollerBody) {
            spollerTitle.removeAttribute('tabindex');
            if (!spollerTitle.classList.contains('_spoller-active')) {
              spollerTitle.nextElementSibling.hidden = true;
            }
          } else {
            spollerTitle.setAttribute('tabindex', '-1');
            spollerTitle.nextElementSibling.hidden = false;
          }
        });
      }
    };
    var setSpollerAction = function setSpollerAction(e) {
      var el = e.target;
      if (el.closest('[data-spoller]')) {
        var spollerTitle = el.closest('[data-spoller]');
        var spollersBlock = spollerTitle.closest('[data-spollers]');
        var oneSpoller = spollersBlock.hasAttribute('data-one-spoller');
        var spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
        if (!spollersBlock.querySelectorAll('._slide').length) {
          if (oneSpoller && !spollerTitle.classList.contains('_spoller-active')) {
            hideSpollersBody(spollersBlock);
          }
          spollerTitle.classList.toggle('_spoller-active');
          _slideToggle(spollerTitle.nextElementSibling, spollerSpeed);
        }
        e.preventDefault();
      }
    };
    var hideSpollersBody = function hideSpollersBody(spollersBlock) {
      var spollerActiveTitle = spollersBlock.querySelector('[data-spoller]._spoller-active');
      var spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
      if (spollerActiveTitle && !spollersBlock.querySelectorAll('._slide').length) {
        spollerActiveTitle.classList.remove('_spoller-active');
        _slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed);
      }
    }; // Закрытие при клике вне спойлера
    // Получение обычных слойлеров
    var spollersRegular = Array.from(spollersArray).filter(function (item, index, self) {
      return !item.dataset.spollers.split(",")[0];
    });
    // Инициализация обычных слойлеров
    if (spollersRegular.length) {
      initSpollers(spollersRegular);
    }
    // Получение слойлеров с медиа запросами
    var mdQueriesArray = dataMediaQueries(spollersArray, "spollers");
    if (mdQueriesArray && mdQueriesArray.length) {
      mdQueriesArray.forEach(function (mdQueriesItem) {
        // Событие
        mdQueriesItem.matchMedia.addEventListener("change", function () {
          initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
        });
        initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
      });
    }
    var spollersClose = document.querySelectorAll('[data-spoller-close]');
    if (spollersClose.length) {
      document.addEventListener("click", function (e) {
        var el = e.target;
        if (!el.closest('[data-spollers]')) {
          spollersClose.forEach(function (spollerClose) {
            var spollersBlock = spollerClose.closest('[data-spollers]');
            if (spollersBlock.classList.contains('_spoller-init')) {
              var spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
              spollerClose.classList.remove('_spoller-active');
              _slideUp(spollerClose.nextElementSibling, spollerSpeed);
            }
          });
        }
      });
    }
  }
}
// Модуь работы с табами =======================================================================================================================================================================================================================
/*
Документация по работе в шаблоне: https://template.fls.guru/template-docs/modul-taby.html
Сниппет (HTML): tabs
*/
function tabs() {
  var tabs = document.querySelectorAll('[data-tabs]');
  var tabsActiveHash = [];
  if (tabs.length > 0) {
    var hash = getHash();
    if (hash && hash.startsWith('tab-')) {
      tabsActiveHash = hash.replace('tab-', '').split('-');
    }
    tabs.forEach(function (tabsBlock, index) {
      tabsBlock.classList.add('_tab-init');
      tabsBlock.setAttribute('data-tabs-index', index);
      tabsBlock.addEventListener("click", setTabsAction);
      initTabs(tabsBlock);
    });

    // Получение слойлеров с медиа запросами
    var mdQueriesArray = dataMediaQueries(tabs, "tabs");
    if (mdQueriesArray && mdQueriesArray.length) {
      mdQueriesArray.forEach(function (mdQueriesItem) {
        // Событие
        mdQueriesItem.matchMedia.addEventListener("change", function () {
          setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
        });
        setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
      });
    }
  }
  // Установка позиций заголовков
  function setTitlePosition(tabsMediaArray, matchMedia) {
    tabsMediaArray.forEach(function (tabsMediaItem) {
      tabsMediaItem = tabsMediaItem.item;
      var tabsTitles = tabsMediaItem.querySelector('[data-tabs-titles]');
      var tabsTitleItems = tabsMediaItem.querySelectorAll('[data-tabs-title]');
      var tabsContent = tabsMediaItem.querySelector('[data-tabs-body]');
      var tabsContentItems = tabsMediaItem.querySelectorAll('[data-tabs-item]');
      tabsTitleItems = Array.from(tabsTitleItems).filter(function (item) {
        return item.closest('[data-tabs]') === tabsMediaItem;
      });
      tabsContentItems = Array.from(tabsContentItems).filter(function (item) {
        return item.closest('[data-tabs]') === tabsMediaItem;
      });
      tabsContentItems.forEach(function (tabsContentItem, index) {
        if (matchMedia.matches) {
          tabsContent.append(tabsTitleItems[index]);
          tabsContent.append(tabsContentItem);
          tabsMediaItem.classList.add('_tab-spoller');
        } else {
          tabsTitles.append(tabsTitleItems[index]);
          tabsMediaItem.classList.remove('_tab-spoller');
        }
      });
    });
  }
  // Работа с контентом
  function initTabs(tabsBlock) {
    var tabsTitles = tabsBlock.querySelectorAll('[data-tabs-titles]>*');
    var tabsContent = tabsBlock.querySelectorAll('[data-tabs-body]>*');
    var tabsBlockIndex = tabsBlock.dataset.tabsIndex;
    var tabsActiveHashBlock = tabsActiveHash[0] == tabsBlockIndex;
    if (tabsActiveHashBlock) {
      var tabsActiveTitle = tabsBlock.querySelector('[data-tabs-titles]>._tab-active');
      tabsActiveTitle ? tabsActiveTitle.classList.remove('_tab-active') : null;
    }
    if (tabsContent.length) {
      tabsContent = Array.from(tabsContent).filter(function (item) {
        return item.closest('[data-tabs]') === tabsBlock;
      });
      tabsTitles = Array.from(tabsTitles).filter(function (item) {
        return item.closest('[data-tabs]') === tabsBlock;
      });
      tabsContent.forEach(function (tabsContentItem, index) {
        tabsTitles[index].setAttribute('data-tabs-title', '');
        tabsContentItem.setAttribute('data-tabs-item', '');
        if (tabsActiveHashBlock && index == tabsActiveHash[1]) {
          tabsTitles[index].classList.add('_tab-active');
        }
        tabsContentItem.hidden = !tabsTitles[index].classList.contains('_tab-active');
      });
    }
  }
  function setTabsStatus(tabsBlock) {
    var tabsTitles = tabsBlock.querySelectorAll('[data-tabs-title]');
    var tabsContent = tabsBlock.querySelectorAll('[data-tabs-item]');
    var tabsBlockIndex = tabsBlock.dataset.tabsIndex;
    function isTabsAnamate(tabsBlock) {
      if (tabsBlock.hasAttribute('data-tabs-animate')) {
        return tabsBlock.dataset.tabsAnimate > 0 ? Number(tabsBlock.dataset.tabsAnimate) : 500;
      }
    }
    var tabsBlockAnimate = isTabsAnamate(tabsBlock);
    if (tabsContent.length > 0) {
      var isHash = tabsBlock.hasAttribute('data-tabs-hash');
      tabsContent = Array.from(tabsContent).filter(function (item) {
        return item.closest('[data-tabs]') === tabsBlock;
      });
      tabsTitles = Array.from(tabsTitles).filter(function (item) {
        return item.closest('[data-tabs]') === tabsBlock;
      });
      tabsContent.forEach(function (tabsContentItem, index) {
        if (tabsTitles[index].classList.contains('_tab-active')) {
          if (tabsBlockAnimate) {
            _slideDown(tabsContentItem, tabsBlockAnimate);
          } else {
            tabsContentItem.hidden = false;
          }
          if (isHash && !tabsContentItem.closest('.popup')) {
            setHash("tab-".concat(tabsBlockIndex, "-").concat(index));
          }
        } else {
          if (tabsBlockAnimate) {
            _slideUp(tabsContentItem, tabsBlockAnimate);
          } else {
            tabsContentItem.hidden = true;
          }
        }
      });
    }
  }
  function setTabsAction(e) {
    var el = e.target;
    if (el.closest('[data-tabs-title]')) {
      var tabTitle = el.closest('[data-tabs-title]');
      var tabsBlock = tabTitle.closest('[data-tabs]');
      if (!tabTitle.classList.contains('_tab-active') && !tabsBlock.querySelector('._slide')) {
        var tabActiveTitle = tabsBlock.querySelectorAll('[data-tabs-title]._tab-active');
        tabActiveTitle.length ? tabActiveTitle = Array.from(tabActiveTitle).filter(function (item) {
          return item.closest('[data-tabs]') === tabsBlock;
        }) : null;
        tabActiveTitle.length ? tabActiveTitle[0].classList.remove('_tab-active') : null;
        tabTitle.classList.add('_tab-active');
        setTabsStatus(tabsBlock);
      }
      e.preventDefault();
    }
  }
}
// Модуль работы с меню (бургер) =======================================================================================================================================================================================================================
/*
Документация по работе в шаблоне: https://template.fls.guru/template-docs/menu-burger.html
Сниппет (HTML): menu
*/
function menuInit() {
  if (document.querySelector(".icon-menu")) {
    document.addEventListener("click", function (e) {
      if (bodyLockStatus && e.target.closest('.icon-menu')) {
        bodyLockToggle();
        document.documentElement.classList.toggle("menu-open");
      }
    });
  }
  ;
}
function menuOpen() {
  functions_bodyLock();
  document.documentElement.classList.add("menu-open");
}
function menuClose() {
  functions_bodyUnlock();
  document.documentElement.classList.remove("menu-open");
}
// Модуль "показать еще" =======================================================================================================================================================================================================================
/*
Документация по работе в шаблоне: https://template.fls.guru/template-docs/modul-pokazat-eshhjo.html
Сниппет (HTML): showmore
*/
function showMore() {
  window.addEventListener("load", function (e) {
    var showMoreBlocks = document.querySelectorAll('[data-showmore]');
    var showMoreBlocksRegular;
    var mdQueriesArray;
    if (showMoreBlocks.length) {
      // Получение обычных объектов
      showMoreBlocksRegular = Array.from(showMoreBlocks).filter(function (item, index, self) {
        return !item.dataset.showmoreMedia;
      });
      // Инициализация обычных объектов
      showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;
      document.addEventListener("click", showMoreActions);
      window.addEventListener("resize", showMoreActions);

      // Получение объектов с медиа запросами
      mdQueriesArray = dataMediaQueries(showMoreBlocks, "showmoreMedia");
      if (mdQueriesArray && mdQueriesArray.length) {
        mdQueriesArray.forEach(function (mdQueriesItem) {
          // Событие
          mdQueriesItem.matchMedia.addEventListener("change", function () {
            initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
          });
        });
        initItemsMedia(mdQueriesArray);
      }
    }
    function initItemsMedia(mdQueriesArray) {
      mdQueriesArray.forEach(function (mdQueriesItem) {
        initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
      });
    }
    function initItems(showMoreBlocks, matchMedia) {
      showMoreBlocks.forEach(function (showMoreBlock) {
        initItem(showMoreBlock, matchMedia);
      });
    }
    function initItem(showMoreBlock) {
      var matchMedia = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      showMoreBlock = matchMedia ? showMoreBlock.item : showMoreBlock;
      var showMoreContent = showMoreBlock.querySelectorAll('[data-showmore-content]');
      var showMoreButton = showMoreBlock.querySelectorAll('[data-showmore-button]');
      showMoreContent = Array.from(showMoreContent).filter(function (item) {
        return item.closest('[data-showmore]') === showMoreBlock;
      })[0];
      showMoreButton = Array.from(showMoreButton).filter(function (item) {
        return item.closest('[data-showmore]') === showMoreBlock;
      })[0];
      var hiddenHeight = getHeight(showMoreBlock, showMoreContent);
      if (matchMedia.matches || !matchMedia) {
        if (hiddenHeight < getOriginalHeight(showMoreContent)) {
          _slideUp(showMoreContent, 0, hiddenHeight);
          showMoreButton.hidden = false;
        } else {
          _slideDown(showMoreContent, 0, hiddenHeight);
          showMoreButton.hidden = true;
        }
      } else {
        _slideDown(showMoreContent, 0, hiddenHeight);
        showMoreButton.hidden = true;
      }
    }
    function getHeight(showMoreBlock, showMoreContent) {
      var hiddenHeight = 0;
      var showMoreType = showMoreBlock.dataset.showmore ? showMoreBlock.dataset.showmore : 'size';
      if (showMoreType === 'items') {
        var showMoreTypeValue = showMoreContent.dataset.showmoreContent ? showMoreContent.dataset.showmoreContent : 3;
        var showMoreItems = showMoreContent.children;
        for (var index = 1; index < showMoreItems.length; index++) {
          var showMoreItem = showMoreItems[index - 1];
          hiddenHeight += showMoreItem.offsetHeight;
          if (index == showMoreTypeValue) break;
        }
      } else {
        var _showMoreTypeValue = showMoreContent.dataset.showmoreContent ? showMoreContent.dataset.showmoreContent : 150;
        hiddenHeight = _showMoreTypeValue;
      }
      return hiddenHeight;
    }
    function getOriginalHeight(showMoreContent) {
      var parentHidden;
      var hiddenHeight = showMoreContent.offsetHeight;
      showMoreContent.style.removeProperty('height');
      if (showMoreContent.closest("[hidden]")) {
        parentHidden = showMoreContent.closest("[hidden]");
        parentHidden.hidden = false;
      }
      var originalHeight = showMoreContent.offsetHeight;
      parentHidden ? parentHidden.hidden = true : null;
      showMoreContent.style.height = "".concat(hiddenHeight, "px");
      return originalHeight;
    }
    function showMoreActions(e) {
      var targetEvent = e.target;
      var targetType = e.type;
      if (targetType === 'click') {
        if (targetEvent.closest('[data-showmore-button]')) {
          var showMoreButton = targetEvent.closest('[data-showmore-button]');
          var showMoreBlock = showMoreButton.closest('[data-showmore]');
          var showMoreContent = showMoreBlock.querySelector('[data-showmore-content]');
          var showMoreSpeed = showMoreBlock.dataset.showmoreButton ? showMoreBlock.dataset.showmoreButton : '500';
          var hiddenHeight = getHeight(showMoreBlock, showMoreContent);
          if (!showMoreContent.classList.contains('_slide')) {
            showMoreBlock.classList.contains('_showmore-active') ? _slideUp(showMoreContent, showMoreSpeed, hiddenHeight) : _slideDown(showMoreContent, showMoreSpeed, hiddenHeight);
            showMoreBlock.classList.toggle('_showmore-active');
          }
        }
      } else if (targetType === 'resize') {
        showMoreBlocksRegular && showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;
        mdQueriesArray && mdQueriesArray.length ? initItemsMedia(mdQueriesArray) : null;
      }
    }
  });
}

//================================================================================================================================================================================================================================================================================================================
// Прочие полезные функции ================================================================================================================================================================================================================================================================================================================
//================================================================================================================================================================================================================================================================================================================
// FLS (Full Logging System)
function FLS(message) {
  setTimeout(function () {
    if (window.FLS) {
      console.log(message);
    }
  }, 0);
}
// Получить цифры из строки
function getDigFromString(item) {
  return parseInt(item.replace(/[^\d]/g, ''));
}
// Форматирование цифр типа 100 000 000
function getDigFormat(item) {
  return item.toString().replace(/(\d)(?=(\d\d\d)+([^\d]|$))/g, "$1 ");
}
// Убрать класс из всех элементов массива
function removeClasses(array, className) {
  for (var i = 0; i < array.length; i++) {
    array[i].classList.remove(className);
  }
}
// Уникализация массива
function uniqArray(array) {
  return array.filter(function (item, index, self) {
    return self.indexOf(item) === index;
  });
}
// Функция получения индекса внутри родителя
function indexInParent(parent, element) {
  var array = Array.prototype.slice.call(parent.children);
  return Array.prototype.indexOf.call(array, element);
}
;
// Обработа медиа запросов из атрибутов 
function dataMediaQueries(array, dataSetValue) {
  // Получение объектов с медиа запросами
  var media = Array.from(array).filter(function (item, index, self) {
    if (item.dataset[dataSetValue]) {
      return item.dataset[dataSetValue].split(",")[0];
    }
  });
  // Инициализация объектов с медиа запросами
  if (media.length) {
    var breakpointsArray = [];
    media.forEach(function (item) {
      var params = item.dataset[dataSetValue];
      var breakpoint = {};
      var paramsArray = params.split(",");
      breakpoint.value = paramsArray[0];
      breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
      breakpoint.item = item;
      breakpointsArray.push(breakpoint);
    });
    // Получаем уникальные брейкпоинты
    var mdQueries = breakpointsArray.map(function (item) {
      return '(' + item.type + "-width: " + item.value + "px)," + item.value + ',' + item.type;
    });
    mdQueries = uniqArray(mdQueries);
    var mdQueriesArray = [];
    if (mdQueries.length) {
      // Работаем с каждым брейкпоинтом
      mdQueries.forEach(function (breakpoint) {
        var paramsArray = breakpoint.split(",");
        var mediaBreakpoint = paramsArray[1];
        var mediaType = paramsArray[2];
        var matchMedia = window.matchMedia(paramsArray[0]);
        // Объекты с нужными условиями
        var itemsArray = breakpointsArray.filter(function (item) {
          if (item.value === mediaBreakpoint && item.type === mediaType) {
            return true;
          }
        });
        mdQueriesArray.push({
          itemsArray: itemsArray,
          matchMedia: matchMedia
        });
      });
      return mdQueriesArray;
    }
  }
}
//================================================================================================================================================================================================================================================================================================================
;// CONCATENATED MODULE: ./src/js/common/index.js




window.addEventListener("DOMContentLoaded", onLoaded);
function onLoaded() {
  try {
    drawers.init();
    initMarkOnScroll();
    addIsMobileClass();
  } catch (ex) {
    error(ex);
  }
}
function addIsMobileClass() {
  if (isMobile.any()) {
    document.documentElement.classList.add("is-mobile");
  }
}
function initMarkOnScroll() {
  document.addEventListener("scroll", function () {
    if (window.scrollY > 80) {
      document.documentElement.classList.add("scroll-80-plus");
    } else {
      document.documentElement.classList.remove("scroll-80-plus");
    }
  });
}
}();
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
!function() {
// extracted by mini-css-extract-plugin

}();
/******/ })()
;